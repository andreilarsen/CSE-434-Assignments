#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>

struct header
{
    char magic1;
    char magic2;
    char opcode;
    char payload_len;

    uint32_t token;
    uint32_t msg_id;
};

const int h_size = sizeof(struct header);

// These are the "magic numbers"
#define MAGIC_1     'A'
#define MAGIC_2     'L'

// These are the constants indicating the states
#define STATE_OFFLINE           0
#define STATE_LOGIN_SENT        1
#define STATE_ONLINE            2
#define STATE_LOGOUT_SENT       3
#define STATE_SUBSCRIBE_SENT    4
#define STATE_UNSUBSCRIBE_SENT  5
#define STATE_POST_SENT         6
#define STATE_RETRIEVE_SENT     7

// These are the constants indicating the events. All events starting with EVENT_USER_ are generated by a human user
#define EVENT_USER_LOGIN                    0
#define EVENT_USER_LOGOUT                   1
#define EVENT_USER_POST                     2
#define EVENT_USER_SUBSCRIBE                3
#define EVENT_USER_UNSUBSCRIBE              4
#define EVENT_USER_RETRIEVE                 5
#define EVENT_USER_RESET                    6
#define EVENT_USER_SPURIOS_MESSAGE          7
#define EVENT_USER_INVALID                  79

// All events starting with EVENT_NET_ are generated by receiving a msg from the network. We deliberately use larger numbers to help debug
#define EVENT_NET_LOGIN_SUCCESSFUL          80
#define EVENT_NET_LOGIN_FAILED              81
#define EVENT_NET_LOGOUT_SUCCESSFUL         82
#define EVENT_NET_POST_ACK                  83
#define EVENT_NET_SUBSCRIBE_ACK             84
#define EVENT_NET_SUBSCRIBE_FAILED_ACK      85
#define EVENT_NET_UNSUBSCRIBE_ACK           86
#define EVENT_NET_UNSUBSCRIBE_FAILED_ACK    87
#define EVENT_NET_RETRIEVE_ACK              88
#define EVENT_NET_END_OF_RETRIEVE_ACK       89
#define EVENT_NET_FORWARD                   90
#define EVENT_NET_RESET                     92
#define EVENT_NET_INVALID                   255

// These are the constants indicating the opcodes
// First nibble = 0: two-way
// First nibble = 1: from client
// First nibble = 2: from server
#define OPCODE_SESSION_RESET                0x00
#define OPCODE_MUST_LOGIN_FIRST             0x20
#define OPCODE_LOGIN                        0x10
#define OPCODE_SUCCESSFUL_LOGIN_ACK         0x21
#define OPCODE_FAILED_LOGIN_ACK             0x22
#define OPCODE_SUBSCRIBE                    0x11
#define OPCODE_SUCCESSFUL_SUBSCRIBE_ACK     0x23
#define OPCODE_FAILED_SUBSCRIBE_ACK         0x24
#define OPCODE_UNSUBSCRIBE                  0x12
#define OPCODE_SUCCESSFUL_UNSUBSCRIBE_ACK   0x25
#define OPCODE_FAILED_UNSUBSCRIBE_ACK       0x26
#define OPCODE_POST                         0x13
#define OPCODE_POST_ACK                     0x27
#define OPCODE_FORWARD                      0x28
#define OPCODE_FORWARD_ACK                  0x14
#define OPCODE_RETRIEVE                     0x15
#define OPCODE_RETRIEVE_ACK                 0x29
#define OPCODE_END_OF_RETRIEVE_ACK          0x2A
#define OPCODE_LOGOUT                       0x16
#define OPCODE_LOGOUT_ACK                   0x2B
#define OPCODE_SPURIOS                      0x17    // This opcode is not defined in the server file


int parse_the_event_from_the_input_string(char* user_input)
{
    if(strncmp(user_input, "login#", 6) == 0)
    {
        return EVENT_USER_LOGIN;
    }
    if(strncmp(user_input, "post#", 5) == 0)
    {
        return EVENT_USER_POST;
    }
    if(strncmp(user_input, "retrieve#", 9) == 0)
    {
        return EVENT_USER_RETRIEVE;
    }
    if(strncmp(user_input, "subscribe#", 10) == 0)
    {
        return EVENT_USER_SUBSCRIBE;
    }
    if(strncmp(user_input, "unsubscribe#", 12) == 0)
    {
        return EVENT_USER_UNSUBSCRIBE;
    }
    if(strncmp(user_input, "logout#", 7) == 0)
    {
        return EVENT_USER_LOGOUT;
    }
    if(strncmp(user_input, "reset#", 6) == 0)
    {
        return EVENT_USER_RESET;
    }
    if(strncmp(user_input, "spurious#", 9) == 0)
    {
        return EVENT_USER_SPURIOS_MESSAGE;
    }
    return EVENT_USER_INVALID;
}


int parse_the_event_from_the_received_message(char* recv_buffer)
{
    if(recv_buffer[0] != MAGIC_1 || recv_buffer[1] != MAGIC_2)
    {
        return EVENT_NET_INVALID;
    }
    if(recv_buffer[2] == OPCODE_SUCCESSFUL_LOGIN_ACK)
    {
        return EVENT_NET_LOGIN_SUCCESSFUL;
    }
    if(recv_buffer[2] == OPCODE_FAILED_LOGIN_ACK)
    {
        return EVENT_NET_LOGIN_FAILED;
    }
    if(recv_buffer[2] == OPCODE_POST_ACK)
    {
        return EVENT_NET_POST_ACK;
    }
    if(recv_buffer[2] == OPCODE_SUCCESSFUL_SUBSCRIBE_ACK)
    {
        return EVENT_NET_SUBSCRIBE_ACK;
    }
    if(recv_buffer[2] == OPCODE_SUCCESSFUL_UNSUBSCRIBE_ACK)
    {
        return EVENT_NET_UNSUBSCRIBE_ACK;
    }
    if(recv_buffer[2] == OPCODE_RETRIEVE_ACK)
    {
        return EVENT_NET_RETRIEVE_ACK;
    }
    if(recv_buffer[2] == OPCODE_END_OF_RETRIEVE_ACK)
    {
        return EVENT_NET_END_OF_RETRIEVE_ACK;
    }
    if(recv_buffer[2] == OPCODE_FORWARD)
    {
        return EVENT_NET_FORWARD;
    }
    if(recv_buffer[2] == OPCODE_FAILED_SUBSCRIBE_ACK)
    {
        return EVENT_NET_SUBSCRIBE_FAILED_ACK;
    }
    if(recv_buffer[2] == OPCODE_FAILED_UNSUBSCRIBE_ACK)
    {
        return EVENT_NET_UNSUBSCRIBE_FAILED_ACK;
    }
    if(recv_buffer[2] == OPCODE_LOGOUT_ACK)
    {
        return EVENT_NET_LOGOUT_SUCCESSFUL;
    }
    if(recv_buffer[2] == OPCODE_SESSION_RESET)
    {
        return EVENT_NET_RESET;
    }
    return EVENT_NET_INVALID;
}


void send_reset(int sockfd, char* send_buffer, struct sockaddr_in serv_addr)
{
    sendto(sockfd, send_buffer, h_size, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));
}


int main(int argc, char* argv[])
{
    char user_input[1024];

    int ret;
    int sockfd = 0;
    int port_number_counter = 32768 + atoi(argv[1]);
    char send_buffer[1024];
    char recv_buffer[1024];
    struct sockaddr_in serv_addr;
    struct sockaddr_in my_addr;
    int maxfd;
    fd_set read_set;
    FD_ZERO(&read_set);

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        printf("socket() error: %s.\n", strerror(errno));
        return -1;
    }

    // The "serv_addr" is the server's address and port number, 
    // i.e, the destination address if the client needs to send something. 
    // Note that this "serv_addr" must match with the address in the 
    // "UDP receive" code.
    // We assume the server is also running on the same machine, and 
    // hence, the IP address of the server is just "127.0.0.1".
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    serv_addr.sin_port = htons(32000);

    // The "my_addr" is the client's address and port number used for  
    // receiving responses from the server.
    // Note that this is a local address, not a remote address.
    memset(&my_addr, 0, sizeof(my_addr));
    my_addr.sin_family = AF_INET;
    my_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    my_addr.sin_port = htons(port_number_counter++);


    // Bind "my_addr" to the socket for receiving messages from the server.
    ret = bind(sockfd, (struct sockaddr *) &my_addr, sizeof(my_addr));
    if (ret < 0)
    {
        printf("binding error!!!");
    }
    maxfd = sockfd + 1; // Note that the file descriptor of stdin is 0
    
    int state = STATE_OFFLINE;
    int event;
    uint32_t token; // Assume the token is a 32-bit integer

    // This is a pointer of the type "struct header" but it always points
    // to the first byte of the "send_buffer", i.e., if we dereference this
    // pointer, we get the first 12 bytes in the "send_buffer" in the format
    // of the structure, which is very convenient.
    // Same for the receive buffer.
    struct header *ph_send = (struct header *)send_buffer;
    struct header *ph_recv = (struct header *)recv_buffer;
    
    while (1)
    {
        // Use select to wait on keyboard input or socket receiving.
        FD_SET(fileno(stdin), &read_set);
        FD_SET(sockfd, &read_set);

        select(maxfd, &read_set, NULL, NULL, NULL);

        if (FD_ISSET(fileno(stdin), &read_set)) // If there is a keyboard input event
        {
            fgets(user_input, sizeof(user_input), stdin);

            // Note that in this parse function, you need to check the
            // user input and figure out what event it is. Basically it
            // will be a long sequence of if (strncmp(user_input, ...) == 0)
            // and if none of the "if" matches, return EVENT_USER_INVALID
            event = parse_the_event_from_the_input_string(user_input);

            // You can also add a line to print the "event" for debugging.
            if (event == EVENT_USER_LOGIN)
            {
                if (state == STATE_OFFLINE)
                {
                    char* id_password = user_input + 6; // skip the "login#"
                    int m = strlen(id_password);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_LOGIN;
                    ph_send->payload_len = m;
                    ph_send->token = 0;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, id_password, m);

                    sendto(sockfd, send_buffer, h_size + m, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    // Once the corresponding action finishes, transit to the login_sent state
                    state = STATE_LOGIN_SENT;
                }
                else 
                {
                    // TODO: handle errors if the event happens in a state
                    // that is not expected. Basically just print an error
                    // message and doing nothing. Note that if a user types
                    // something invalid, it does not need to trigger a 
                    // session reset.
                    printf("ERROR: You tried to login but you're already logged in!\n");
                }

            }
            else if (event == EVENT_USER_POST)
            {
                if(state == STATE_ONLINE)
                {
                    // Note that this is similar to the login msg.
                    // Actually, these messages are carefully designed to 
                    // somewhat minimize the processing on the client side.
                    // If you look at the "subscribe", "unsubscribe", "post"
                    // and "retrieve", they are all similar, i.e., just fill
                    // the header and copy the user input after the "#" as
                    // the payload of the message, then just send the msg.

                    char* text = user_input + 5; // skip the "post#"
                    int m = strlen(text);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_POST;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, text, m);

                    sendto(sockfd, send_buffer, h_size + m, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_POST_SENT;
                }
                else
                {
                    printf("You tried to post# but something else is going on. state=%d.\n", state);
                }
                
            }
            else if (event == EVENT_USER_SUBSCRIBE)
            {
                if(state == STATE_ONLINE)
                {
                    // Note that this is similar to the login msg.
                    // Actually, these messages are carefully designed to 
                    // somewhat minimize the processing on the client side.
                    // If you look at the "subscribe", "unsubscribe", "post"
                    // and "retrieve", they are all similar, i.e., just fill
                    // the header and copy the user input after the "#" as
                    // the payload of the message, then just send the msg.

                    char* text = user_input + 10; // skip the "subscribe#"
                    int m = strlen(text);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_SUBSCRIBE;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, text, m);

                    sendto(sockfd, send_buffer, h_size + m, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_SUBSCRIBE_SENT;
                }
                else
                {
                    printf("You tried to subscribe# but something else is going on. state=%d.\n", state);
                }
            }
            else if (event == EVENT_USER_UNSUBSCRIBE)
            {
                if(state == STATE_ONLINE)
                {
                    // Note that this is similar to the login msg.
                    // Actually, these messages are carefully designed to 
                    // somewhat minimize the processing on the client side.
                    // If you look at the "subscribe", "unsubscribe", "post"
                    // and "retrieve", they are all similar, i.e., just fill
                    // the header and copy the user input after the "#" as
                    // the payload of the message, then just send the msg.

                    char* text = user_input + 12; // skip the "unsubscribe#"
                    int m = strlen(text);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_UNSUBSCRIBE;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, text, m);

                    sendto(sockfd, send_buffer, h_size + m, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_UNSUBSCRIBE_SENT;
                }
                else
                {
                    printf("You tried to unsubscribe# but something else is going on. state=%d.\n", state);
                }
            }
            else if (event == EVENT_USER_RETRIEVE)
            {
                if(state == STATE_ONLINE)
                {
                    // Note that this is similar to the login msg.
                    // Actually, these messages are carefully designed to 
                    // somewhat minimize the processing on the client side.
                    // If you look at the "subscribe", "unsubscribe", "post"
                    // and "retrieve", they are all similar, i.e., just fill
                    // the header and copy the user input after the "#" as
                    // the payload of the message, then just send the msg.

                    char* text = user_input + 9; // skip the "retrieve#"
                    int m = strlen(text);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_RETRIEVE;
                    ph_send->payload_len = m;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    memcpy(send_buffer + h_size, text, m);

                    sendto(sockfd, send_buffer, h_size + m, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_RETRIEVE_SENT;
                }
                else
                {
                    printf("You tried to retrieve# but something else is going on. state=%d.\n", state);
                }
            }
            else if (event == EVENT_USER_LOGOUT)
            {
                if(state == STATE_ONLINE)
                {
                    // Note that this is similar to the login msg.
                    // Actually, these messages are carefully designed to 
                    // somewhat minimize the processing on the client side.
                    // If you look at the "subscribe", "unsubscribe", "post"
                    // and "retrieve", they are all similar, i.e., just fill
                    // the header and copy the user input after the "#" as
                    // the payload of the message, then just send the msg.

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_LOGOUT;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    sendto(sockfd, send_buffer, h_size, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    state = STATE_LOGOUT_SENT;
                }
                else
                {
                    printf("You tried to logout# but something else is going on. state=%d.\n", state);
                }
            }
            else if (event == EVENT_USER_RESET)
            {
                if(state == STATE_ONLINE)
                {
                    // TODO: You may add another command like "reset#" so as to
                    // facilitate testing. In this case, a user just need to 
                    // type this line to generate a reset message.

                    // You can add more commands as you like to help debugging.
                    // For example, I can add a command "state#" to instruct the
                    // client program to print the current state without chang
                    // -ing anything.

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_SESSION_RESET;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    sendto(sockfd, send_buffer, h_size, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                    printf("reset#successful\n");

                    state = STATE_OFFLINE;
                }
                else
                {
                    printf("You tried to reset# but something else is going on. state=%d.\n", state);
                }
            }
            else if (event == EVENT_USER_SPURIOS_MESSAGE)
            {
                ph_send->magic1 = MAGIC_1;
                ph_send->magic2 = MAGIC_2;
                ph_send->opcode = OPCODE_SPURIOS;
                ph_send->payload_len = 0;
                ph_send->token = token;
                ph_send->msg_id = 0;

                sendto(sockfd, send_buffer, h_size, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));

                printf("spurious#successful\n");

                // No need to change state
            }
            else    // if (event == EVENT_USER_INVALID)
            {
                printf("That's not a valid input. Please try again.\n");
                state = STATE_ONLINE;
            }
        }
        if (FD_ISSET(sockfd, &read_set))    // If there is an event from the network
        {
            memset(recv_buffer, 0, sizeof(recv_buffer));
            ret = recv(sockfd, recv_buffer, sizeof(recv_buffer), 0);

            event = parse_the_event_from_the_received_message(recv_buffer);

            if (event == EVENT_NET_LOGIN_SUCCESSFUL)
            {
                if (state == STATE_LOGIN_SENT)
                {
                    token = ph_recv->token;

                    printf("login_ack#successful\n");
                    state = STATE_ONLINE;
                }
                else
                {
                    // A spurious msg is received. Just reset the session.
                    // You can define a function "send_reset()" for 
                    // convenience because it might be used in many places.
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_LOGIN_FAILED)
            {
                if (state == STATE_LOGIN_SENT)
                {
                    printf("login_ack#failed\n");
                    state = STATE_OFFLINE;
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_FORWARD)
            {
                if (state == STATE_ONLINE)
                {
                    // Just extract the payload and print the text.
                    char* text = recv_buffer + h_size;

                    printf("%s", text);

                    ph_send->magic1 = MAGIC_1;
                    ph_send->magic2 = MAGIC_2;
                    ph_send->opcode = OPCODE_FORWARD_ACK;
                    ph_send->payload_len = 0;
                    ph_send->token = token;
                    ph_send->msg_id = 0;

                    sendto(sockfd, send_buffer, h_size, 0, (struct sockaddr *) &serv_addr, sizeof(serv_addr));
                    // Note that no state change is needed.
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_LOGOUT_SUCCESSFUL)
            {
                if (state == STATE_LOGOUT_SENT)
                {
                    printf("logout#successful\n");
                    state = STATE_OFFLINE;
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_POST_ACK)
            {
                if (state == STATE_POST_SENT)
                {
                    printf("post#successful\n");
                    state = STATE_ONLINE;
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_SUBSCRIBE_ACK)
            {
                if (state == STATE_SUBSCRIBE_SENT)
                {
                    printf("subscribe#successful\n");
                    state = STATE_ONLINE;
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }else if (event == EVENT_NET_SUBSCRIBE_FAILED_ACK)
            {
                if (state == STATE_SUBSCRIBE_SENT)
                {
                    printf("subscribe#failed\n");
                    state = STATE_ONLINE;
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_UNSUBSCRIBE_ACK)
            {
                if (state == STATE_UNSUBSCRIBE_SENT)
                {
                    printf("unsubscribe#successful\n");
                    state = STATE_ONLINE;
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_UNSUBSCRIBE_FAILED_ACK)
            {
                if (state == STATE_UNSUBSCRIBE_SENT)
                {
                    printf("unsubscribe#failed\n");
                    state = STATE_ONLINE;
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_RETRIEVE_ACK)
            {
                if (state == STATE_RETRIEVE_SENT)
                {
                    // Similar to EVENT_NET_FORWARD
                    // Just extract the payload and print the text.
                    char* text = recv_buffer + h_size;

                    printf("%s", text);

                    // Note that no state change is needed.
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_END_OF_RETRIEVE_ACK)
            {
                if (state == STATE_RETRIEVE_SENT)
                {
                    printf("rerieve#successful\n");
                    state = STATE_ONLINE;
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else if (event == EVENT_NET_RESET)
            {
                if (state == STATE_ONLINE)
                {
                    printf("The session was reset by the server\n");
                    state = STATE_OFFLINE;
                }
                else
                {
                    send_reset(sockfd, send_buffer, serv_addr);
                    state = STATE_OFFLINE;
                }
            }
            else    // if (event == EVENT_NET_INVALID)
            {
                send_reset(sockfd, send_buffer, serv_addr);
                state = STATE_OFFLINE;
            }
        }
        
        
        // Now we finished processing the pending event. Just go back to the
        // beginning of the loop and waiting for another event. 
        // Note that you can set a timeout for the select() function 
        // to allow it to return regularly and check timeout related events.

    } // This is the end of the while loop

    return 0;   // Should never execute
} // This is the end of main()